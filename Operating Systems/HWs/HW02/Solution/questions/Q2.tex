\section{سوال دوم}

‫خروجی‬ ‫قطعه‬ ‫کد‬ ‫زیر را‬ ‫پیش‬ ‫بینی‬ ‫کنید‬ ‫و‬ ‫پیش‬ ‫بینی‬ ‫خود‬ ‫را‬ ‫توضیح‬ ‫دهید. ‬‬‫سپس‬ ‫به ‬‫سوالات‬ ‫زیر‬ ‫پاسخ‬ ‫دهید‬.

\begin{latin}
\begin{lstlisting}[label=first,caption=Some Code, language=C]
	
#define NUM_THREADS 3
int shared_value = 10

void* ‫‪increaseValu‬‬e(void* ‫‪threadID‬‬)
{
  long tid = (long)threadID‬‬;
  printf("‫‪Thread‬‬%id:shared value before ‫‪increament‬‬:%d\n", tid, shared_value);
  shared_value += 5;
  printf("‫‪Thread‬‬%id:shared value after ‫‪increament‬‬:%d\n", tid, shared_value);
  ‪pthread_exit‬‬(NULL);
}

int main()
{
  ‫‪pthread_t‬‬ ‫‪threads‬‬ [‫‪NUM_THREADS‬‬];
  long t;
  for(t=0; t<NUM_THREADS; t++)
  {
    printf("‫‪creating‬‬ ‫‪thread‬‬ %id\n", t);
	‫‪pthread_create‬‬(&‫‪threads‬‬[t], NULL, ‫‪increaseValue‬‬, (void*)t);
  }
  
  for(t=0; t<NUM_THREADS; t++)
  {
  	‫‪pthread_join‬‬(threads‬‬[t], NULL);
  }
  
 printf("All threads have completed. Final shared value: %d\n", ‫‪shared_value‬‬);
 ‫‪pthread_exit‬‬(NULL);
 
 return 0;
}
	
\end{lstlisting}
\end{latin}



\begin{qsolve}
	این برنامه، یک برنامه چندنخی‌ست که از کتابخانه pthread برای ایجاد و مدیریت نخ‌ها استفاده می‌کند. برنامه شامل تابع \texttt{increaseValue} است که توسط هر نخ صدا زده می‌شود. هر نخ درون تابع \texttt{increaseValue} مقدار مشترک \texttt{shared\_value} را افزایش می‌دهد. سپس در تابع \texttt{main}، نخ‌ها ایجاد و به صورت موازی اجرا می‌شوند. پس از اتمام هر نخ، با استفاده از تابع \texttt{pthread\_join}، منتظر تمام شدن هر نخ می‌ماند و در نهایت مقدار نهایی \texttt{shared\_value} چاپ می‌شود.
	
	
	
	\begin{enumerate}
		\item ‫در‬ ‫صورتی‬ ‫که‬ ‫دو‬ ‫تابع‬ ‫‪\texttt{pthread\_create}‬‬ ‫و‬ ‫‪\texttt{pthread\_join}‬‬ ‫در‬ ‫یک‬ ‫حلقه‬ ‫صدا‬ ‫زده‬ ‫شوند‬ ‫‪.‬‬‫خروجی‬ ‫برنامه‬ ‫چه‬ ‫خواهد ‬‫بود‬ ‫و‬ ‫علت‬ ‫ان‬ ‫را‬ ‫توضیح‬ ‫دهید‬\\ \textbf{توضیحات: }
		در صورتی که توابع \texttt{pthread\_create} و \texttt{pthread\_join} در یک حلقه صدا زده شوند، خروجی برنامه نامعلوم است. زیرا عملکرد توابع مذکور بستگی به زمانبندی سیستم عامل و زمان اجرای هر نخ دارد. وقتی توابع در یک حلقه صدا زده می‌شوند، ترتیب شروع و اجرای نخ‌ها ممکن است تغییر کند و به همین دلیل خروجی برنامه قابل پیش‌بینی نیست. بنابراین، مقدار \texttt{shared\_value} در نهایت ممکن است نامعلوم باشد
	
	
	
	\item ‫تفاوت‬ ‫بین‬ ‫استفاده‬ ‫از‬ ‫رشته‬ ‫ها‬ ‫و‬ ‫استفاده‬ ‫از‬ ‫‪\texttt{fork}‬‬ ‫برای‬ ‫رسیدن‬ ‫به‬ ‫موازی‬ ‫سازی‬ ‫را‬ ‫توضیح‬ ‫دهید‬. \\ \textbf{توضیحات: }
	تفاوت استفاده از \texttt{Threads} و استفاده از \texttt{fork} برای موازی‌سازی به شرح زیر است:
	\begin{enumerate}
		\item \textbf{:Threads}در برنامه‌نویسی چندنخی با استفاده از رشته‌ها، پردازش موازی در یک فرآیند انجام می‌شود. تمام رشته‌ها در یک فضای آدرسی مشترک قرار دارند و می‌توانند به طور مستقیم به منابع و متغیرهای مشترک دسترسی داشته باشند. این باعث اشتراک منابع و ارتباط آسان بین رشته‌ها می‌شود. با ایجاد رشته‌ها، هزینه ایجاد و تغییر حالت آنها کمتر از هزینه ایجاد و تغییر حالت فرآیندها است
	
		\item \textbf{:fork} در زمان استفاده از fork برای موازی‌سازی، یک فرآیند اصلی و یک فرآیند جدید ایجاد می‌شود. هر فرآیند جدید دارای یک فضای آدرسی مستقل است و هیچ اشتراکی با فرآیند اصلی ندارد. برای ارتباط بین فرآیندها، مکانیزم‌هایی مانند لوله‌ها (pipes) یا صف‌صفحه‌های پیوندی (shared memory) بین فرآیندها بکار می‌روند. هزینه ایجاد و تغییر حالت فرآیندها بیشتر از هزینه رشته‌ها است
	\end{enumerate}
	
	
	\item ‫آیا‬ ‫چند‬ ‫نخ‬ ‫می‬ ‫توانند ‬‫تابع‬ ‫‪\texttt{pthread\_join}‬‬ ‫را‬ ‫بر‬ ‫روی‬ ‫یک‬ ‫نخ‬ ‫هدف‬ ‫فراخوانی‬ ‫کنند‬ ‫یا‬ ‫محدودیتی‬ ‫وجود‬ ‫دارد‬ ‫که‬ ‫تنها‬ ‫یک ‬‫نخ‬ ‫انتظارها‬ ‫را‬ ‫برای‬ ‫هر‬ ‫نخ‬ ‫هدف‬ ‫می‬ ‫تواند‬‫داشته‬ ‫باشد؟ \\ \textbf{توضیحات: }‬
	در برنامه‌های چندنخی، تابع \texttt{pthread\_join} برای انتظار تمام شدن یک نخ هدف استفاده می‌شود. هر نخ می‌تواند تابع \texttt{pthread\_join} را بر روی هر نخ هدف فراخوانی کند و منتظر تمام شدن آن نخ باشد. بنابراین، با توجه به سوال شما، می‌توان تعدادی نخ تابع \texttt{pthread\_join} را بر روی یک نخ هدف فراخوانی کنند و هرکدام از این نخ‌ها منتظر تمام شدن آن نخ هدف خواهند بود. محدودیتی در تعداد نخ‌هایی که می‌توانند تابع \texttt{pthread\_join} را بر روی یک نخ هدف فراخوانی کنند وجود ندارد
	
	\end{enumerate}
	
	
\end{qsolve}



