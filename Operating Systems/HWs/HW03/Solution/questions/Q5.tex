\section{سوال پنجم}

\begin{enumerate}
	\item بدون استفاده از قفل و تنها با استفاده از دستور CompareAndSwap تابع زیر را به گونه ای کامل کنید که به صورت اتمی عملیات تفریق را انجام دهد. منظور از عملیات تفریق کم شدن مقدار V از حافظه ای که P به آن اشاره دارد. سپس توضیح دهید تضمینی برای انجام شدن این عملیات وجود دارد یا خیر

\begin{latin}
\begin{lstlisting}
int sub(int *p, int v)
{
  // TODO
  return *p-v
}		
\end{lstlisting}
\end{latin}

برای استفاده از دستور CompareAndSwap از دستور زیر استفاده کنید:

\begin{latin}
\begin{lstlisting}
bool CompareAndSwap(int *p, int old, int new)
{
  if(*p != old)
  {
  	return false;
  }
  else
  {
  	return true;
  }
}
\end{lstlisting}
\end{latin}


\begin{qsolve}
	برای انجام عملیات تفریق به صورت اتمی می‌تواند از تابع زیر استفاده کرد:
\begin{latin}
\begin{lstlisting}
int sub(int *p, int v)
{
  int old_val, new_val;
  do
  {
  	old_val = *p;
  	new_val = old_val - v;
  } while (!CompareAndSwap(p, old_val, new_val));
  
  return new_val;
}
\end{lstlisting}
\end{latin}

تابع CompareAndSwap بررسی می‌کند که مقدار فعلی در حافظه با مقدار قبلی که در تابع CompareAndSwap به عنوان ورودی داده شده برابر است یا خیر. اگر برابر بود، مقدار جدید در مکان مورد نظر قرار داده می‌شود و عملیات تفریق انجام می‌شود. در غیر این صورت، عملیات تفریق انجام نمی‌شود و تکرار دیگری صورت می‌گیرد تا زمانی که مقدار فعلی در حافظه با مقدار قبلی تطابق داشته باشد.

با استفاده از این روش، تضمین می‌شود که تغییرات در مقدار حافظه از طریق عملیات تفریق انجام می‌شود و در صورتی که همزمان تغییر دیگری در مقدار حافظه صورت گیرد، تابع CompareAndSwap بازخوانی می‌شود و تغییر با موفقیت انجام نمی‌شود. به این ترتیب، عملیات تفریق به صورت اتمی و بدون تداخل با عملیات دیگر در حافظه انجام می‌شود.
\end{qsolve}




\item حال توضیح دهید CompareAndSwap چگونه کنترل همزمانی را در برنامه های چند نخی را بهبود می‌بخشد و در چه مواقعی کاربرد دارد؟


\begin{qsolve}
به طور کلی، تابع CompareAndSwap بهبود کنترل همزمانی در برنامه‌های چند تابع CompareAndSwap یک عملیات همزمانی است که در برنامه‌های چندنخی استفاده می‌شود و در بهبود کنترل همزمانی نخ‌ها نقش مهمی دارد. CAS به صورت اتمی عملیات خواندن و نوشتن را انجام می‌دهد، به این معنی که در یک عملیات تکمیل شده، مقدار قبلی در حافظه را بررسی کرده و اگر با مقدار تعیین شده برابر بود، مقدار جدید را در حافظه قرار می‌دهد. اگر مقدار قبلی با مقدار تعیین شده برابر نبود، تغییری انجام نمی‌شود.

با استفاده از تابع CAS، می‌توان کنترل همزمانی بین نخ‌ها را بهبود بخشید و مشکلاتی که در همزمانی ممکن است پیش بیاید را رفع کرد. از جمله مواردی که CAS کاربرد دارد می‌توان به موارد زیر اشاره کرد:

\begin{itemize}
	\item \textbf{همگام‌سازی دسترسی به منابع مشترک: }در برنامه‌های چندنخی، اگر نخ‌ها به منابع مشترک دسترسی داشته باشند، ممکن است همزمانی مشکلاتی ایجاد کند. با استفاده از تابع ،CAS می‌توان همگام‌سازی دسترسی به منابع را بهبود بخشید و تداخل‌ها را کاهش داد.
	
	\item \textbf{تحقق عملیات اتمی: }در برخی موارد، نیاز است که یک عملیات را به صورت اتمی انجام داده و تضمین کنیم که هیچ تغییر همزمانی دیگری در آن زمان انجام نشده است. با استفاده از تابع ،CAS می‌توان عملیات‌هایی مانند تفریق اتمی، اضافه کردن به مجموعه Add Atomic یا جایگزینی اتمی Swap Atomic را پیاده‌سازی کرد.
	
	\item \textbf{روش‌های بدون انتظار:} تابع CAS به صورت NonBlocking عمل می‌کند، به این معنی که اگر نخ دیگری قفل را نگه داشته باشد، نخ دیگری که از CAS استفاده می‌کند، به صورت مداوم بررسی می‌کند تا زمانی که قفل آزاد شود و عملیات را انجام دهد. این روش می‌تواند در بهبود عملکرد و کاهش هزینه‌های همزمانی در برنامه‌های چندنخی مؤثر باشد.
\end{itemize}

\end{qsolve}

\end{enumerate}