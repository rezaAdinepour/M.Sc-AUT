\section{سوال سوم}

شروط exclution Manual و Progress و  waiting Bounded را برای الکوریتم‌های زیر بررسی کرده و با دلیل توضیح دهید. فرض کنید i و j اعدادی هستند که اندیس پردازه را مشخص می‌کنند.

\begin{latin}
\begin{lstlisting}[caption=Code I]
do
{
	flag[i] = true;
	turn = j;
	while(!flag[j] || turn == j);
		// critical section
	flag[i] = false;
		// remainder section
} while(true);
\end{lstlisting}
\end{latin}


\begin{qsolve}
	الگوریتم فوق یک نمونه از الگوریتم بسته‌بندی دوباره پترسون است که برای رسیدگی به مسئله‌ی تضمین منابع اشتراکی بین دو پردازه طراحی شده است. در این الگوریتم، سه شرط اصلی وجود دارد که باید برای آن‌ها اطمینان حاصل شود:
	
	\begin{enumerate}
		\item شرط manual :exclusion
		 این شرط مشخص می‌کند که در هر لحظه حداکثر یکی از پردازه‌ها می‌تواند در بخش بحرانی حضور داشته باشد. در این الگوریتم، این شرط توسط بخش
		 \begin{latin}
		 	\texttt{while (!flag[j] || turn == j} 
		 \end{latin}
بررسی می‌شود. در این بخش، اگر flag پردازه j فعال باشد و همچنین متغیر turn برابر با j باشد، به این معنی است که پردازه j در بخش بحرانی قرار دارد و بنابراین پردازه فعلی باید منتظر شود تا پردازه j از بخش بحرانی خارج شود.
		
		
		
		\item شرط :progress
		 این شرط تضمین می‌کند که اگر هیچیک از پردازه‌ها در بخش بحرانی قرار نداشته باشد و یک پردازه درخواست ورود به بخش بحرانی داشته باشد، آن پردازه به زودی وارد بخش بحرانی شود. در این الگوریتم، این شرط توسط بخش
		 \begin{latin}
		 	\texttt{flag[i] = true} 
		 \end{latin}
بررسی می‌شود. در این بخش، flag پردازه فعلی فعال می‌شود تا نشان دهد که پردازه فعلی دسترسی به بخش بحرانی می‌خواهد.
		
		
		
		
		\item شرط bounded :waiting
		 این شرط مشخص می‌کند که پردازه‌ها در صورت درخواست ورود به بخش بحرانی، به طور محدود در حال انتظار باشند و پردازه‌ای بی‌نهایت در انتظار نباشد. در الگوریتم فوق، این شرط توسط بخش 
\begin{latin}
	\texttt{while (!flag[j] || turn == j)}
\end{latin}
بررسی می‌شود. در این بخش، اگر پرچم پردازه j فعال باشد و متغیر turn برابر با j باشد، به این معنی است که پردازه j در بخش بحرانی قرار دارد و پردازه فعلی باید منتظر شود تا پردازه j از بخش بحرانی خارج شود. این باعث می‌شود که پردازه‌ها در صورت درخواست ورود به بخش بحرانی، به صورتمحدود در حالت انتظار قرار بگیرند و پردازه‌ی فعلی نیز منتظر بماند تا بتواند وارد بخش بحرانی شود.\\
	\end{enumerate}
\end{qsolve}


\begin{latin}
\begin{lstlisting}[caption=Code II]
do
{
	flag[i] = true;
	turn = j;
	while(!flag[j] && turn == j);
		// critical section
	flag[i] = false;
		// remainder section
} while(true);
\end{lstlisting}
\end{latin}


\begin{qsolve}
	الگوریتم بالا نیز یک نمونه از الگوریتم بسته‌بندی دوباره پترسون است، اما با تفاوتی در شرط بررسی حلقه while دارد. در این الگوریتم، شرایط خواسته شده به شرح زیر بررسی می‌شوند:
	
	\begin{enumerate}
		\item شرط manual :exclusion
بخش بررسی شرط manual exclusion در الگوریتم فوق به وسیله عبارت
\begin{latin}
	\texttt{while (!flag[j] \&\& turn == j)}  
\end{latin}
 انجام می‌شود. این بخش برای ورود به بخش بحرانی همزمانی پردازه‌ها را بررسی می‌کند. اگر پرچم پردازه j غیرفعال باشد و مقدار متغیر turn برابر با j باشد، به این معنی است که هیچ پردازه‌ای در حال حاضر در بخش بحرانی حضور ندارد و پردازه فعلی می‌تواند وارد بخش بحرانی شود. این شرط تضمین می‌کند که حداکثر یک پردازه در بخش بحرانی حضور داشته باشد.
		
		
		\item شرط :progress
شرط progress در این الگوریتم به صورت ضمنی تضمین می‌شود. عبارت
\begin{latin}
	\texttt{flag[i] = true} 
\end{latin}
  بلافاصله پس از ورود به حلقه اجرا می‌شود و شرط progress را برآورده می‌کند. این عبارت مشخص می‌کند که پردازه فعلی درخواست ورود به بخش بحرانی دارد و آماده است در آن وارد شود. اگر هیچ پردازه‌ای در حالت بحرانی قرار نگیرد، پردازه فعلی به زودی وارد بخش بحرانی خواهد شد.
		
		\item شرط bounded :waiting
خش بررسی شرط waiting bounded نیز با استفاده از عبارت
\begin{latin}
	\texttt{while (!flag[j] \&\& turn == j)}
\end{latin}
انجام می‌شود. اگر پرچم پردازه j غیرفعال باشد و مقدار متغیر turn برابر با j باشد، به این معنی است که هیچ پردازه‌ای در حال حاضر در بخش بحرانی حضور ندارد و پردازه فعلی می‌تواند وارد بخش بحرانی شود. این باعث می‌شود که پردازه‌ها در صورت درخواست ورود به بخش بحرانی، به صورت محدود در حالت انتظار قرار بگیرند و پردازه‌ی فعلی نیز منتظر بماند تا بتواند وارد بخش بحرانی شود.
		
	\end{enumerate}
\end{qsolve}








